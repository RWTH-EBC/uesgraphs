

<!DOCTYPE html>
<html class="writer-html5" lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>uesgraphs.analyze &mdash; uesgraphs 2.1.1 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../_static/pygments.css" />
      <link rel="stylesheet" type="text/css" href="../../_static/css/theme.css" />

  
      <script src="../../_static/jquery.js"></script>
      <script src="../../_static/_sphinx_javascript_frameworks_compat.js"></script>
      <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
      <script src="../../_static/doctools.js"></script>
      <script src="../../_static/sphinx_highlight.js"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../index.html" class="icon icon-home">
            uesgraphs
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../code/modules.html">uesgraphs</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../_autosummary/uesgraphs.UESGraph.html">uesgraphs.UESGraph</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../_autosummary/uesgraphs.Visuals.html">uesgraphs.Visuals</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../_autosummary/uesgraphs.uesgraph.html">uesgraphs.uesgraph</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../_autosummary/uesgraphs.visuals.html">uesgraphs.visuals</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../_autosummary/uesgraphs.analyze.html">uesgraphs.analyze</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../_autosummary/uesgraphs.template_generation.html">uesgraphs.template_generation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../_autosummary/uesgraphs.utilities.html">uesgraphs.utilities</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../_autosummary/uesgraphs.systemmodels.templates.html">uesgraphs.systemmodels.templates</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../_autosummary/uesgraphs.examples.html">uesgraphs.examples</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">uesgraphs</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../index.html">Module code</a></li>
          <li class="breadcrumb-item"><a href="../uesgraphs.html">uesgraphs</a></li>
      <li class="breadcrumb-item active">uesgraphs.analyze</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for uesgraphs.analyze</h1><div class="highlight"><pre>
<span></span><span class="kn">import</span><span class="w"> </span><span class="nn">uesgraphs</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">ug</span>


<span class="kn">import</span><span class="w"> </span><span class="nn">os</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">List</span><span class="p">,</span> <span class="n">Dict</span><span class="p">,</span> <span class="n">Generator</span><span class="p">,</span> <span class="n">Optional</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">pyarrow.parquet</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">pq</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">re</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">pandas</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">pd</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">logging</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">datetime</span><span class="w"> </span><span class="kn">import</span> <span class="n">datetime</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">tempfile</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">sys</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">networkx</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">nx</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">uesgraphs.data.mat_handler</span><span class="w"> </span><span class="kn">import</span> <span class="n">mat_to_parquet</span>



<span class="kn">import</span><span class="w"> </span><span class="nn">matplotlib.pyplot</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">plt</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">matplotlib.dates</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">mdates</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">matplotlib.ticker</span><span class="w"> </span><span class="kn">import</span> <span class="n">FuncFormatter</span>

<span class="c1">#### Global Variables ####</span>

<span class="n">MASKS</span> <span class="o">=</span> <span class="kc">None</span> <span class="c1"># Dictionary to store masks for column names</span>

<span class="c1">#### Functions 1: Logger ####</span>
<div class="viewcode-block" id="set_up_logger"><a class="viewcode-back" href="../../code/uesgraphs.html#uesgraphs.analyze.set_up_logger">[docs]</a><span class="k">def</span><span class="w"> </span><span class="nf">set_up_logger</span><span class="p">(</span><span class="n">name</span><span class="p">,</span><span class="n">log_dir</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span><span class="n">level</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="n">logging</span><span class="o">.</span><span class="n">ERROR</span><span class="p">)):</span>
        <span class="n">logger</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">setLevel</span><span class="p">(</span><span class="n">level</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">log_dir</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">log_dir</span> <span class="o">=</span> <span class="n">tempfile</span><span class="o">.</span><span class="n">gettempdir</span><span class="p">()</span>
        <span class="n">timestamp</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span><span class="o">.</span><span class="n">strftime</span><span class="p">(</span><span class="s2">&quot;%Y%m</span><span class="si">%d</span><span class="s2">_%H%M%S&quot;</span><span class="p">)</span>
        <span class="n">log_file</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">log_dir</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2">_</span><span class="si">{</span><span class="n">timestamp</span><span class="si">}</span><span class="s2">.log&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Logfile findable here: </span><span class="si">{</span><span class="n">log_file</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">handler</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">FileHandler</span><span class="p">(</span><span class="n">log_file</span><span class="p">)</span>
        <span class="n">formatter</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">Formatter</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%(asctime)s</span><span class="s1"> - </span><span class="si">%(name)s</span><span class="s1"> - [</span><span class="si">%(filename)s</span><span class="s1">:</span><span class="si">%(lineno)d</span><span class="s1">] - </span><span class="si">%(levelname)s</span><span class="s1"> - </span><span class="si">%(message)s</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="n">handler</span><span class="o">.</span><span class="n">setFormatter</span><span class="p">(</span><span class="n">formatter</span><span class="p">)</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">addHandler</span><span class="p">(</span><span class="n">handler</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">logger</span></div>

<span class="c1">#### Functions 2: Data Processing ####</span>

<div class="viewcode-block" id="process_parquet_file"><a class="viewcode-back" href="../../code/uesgraphs.html#uesgraphs.analyze.process_parquet_file">[docs]</a><span class="k">def</span><span class="w"> </span><span class="nf">process_parquet_file</span><span class="p">(</span><span class="n">file_path</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">filter_list</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> 
                        <span class="n">chunk_size</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">100000</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Generator</span><span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Process a parquet file in chunks to reduce memory usage.</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        file_path: Path to the parquet file</span>
<span class="sd">        filter_list: List of column patterns to filter</span>
<span class="sd">        chunk_size: Number of rows to process at once</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Read parquet file metadata to get columns</span>
    <span class="n">parquet_file</span> <span class="o">=</span> <span class="n">pq</span><span class="o">.</span><span class="n">ParquetFile</span><span class="p">(</span><span class="n">file_path</span><span class="p">)</span>
    <span class="n">all_columns</span> <span class="o">=</span> <span class="n">parquet_file</span><span class="o">.</span><span class="n">schema</span><span class="o">.</span><span class="n">names</span>
    
    <span class="c1"># Pre-filter columns based on filter_list to reduce memory usage</span>
    <span class="n">columns_to_read</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">pattern</span> <span class="ow">in</span> <span class="n">filter_list</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">pattern</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s1">&#39;$&#39;</span><span class="p">):</span>
            <span class="c1"># Regex filter</span>
            <span class="n">regex_pattern</span> <span class="o">=</span> <span class="n">pattern</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="s1">&#39;$&#39;</span>
            <span class="n">columns_to_read</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span>
                <span class="n">col</span> <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">all_columns</span> 
                <span class="k">if</span> <span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">regex_pattern</span><span class="p">,</span> <span class="n">col</span><span class="p">)</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Simple string filter</span>
            <span class="n">columns_to_read</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span>
                <span class="n">col</span> <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">all_columns</span> 
                <span class="k">if</span> <span class="n">pattern</span> <span class="ow">in</span> <span class="n">col</span>
            <span class="p">)</span>
    
    <span class="c1"># Remove duplicates while preserving order</span>
    <span class="n">columns_to_read</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">dict</span><span class="o">.</span><span class="n">fromkeys</span><span class="p">(</span><span class="n">columns_to_read</span><span class="p">))</span>
    
    <span class="c1"># Read and process the file in chunks</span>
    <span class="k">for</span> <span class="n">chunk</span> <span class="ow">in</span> <span class="n">parquet_file</span><span class="o">.</span><span class="n">iter_batches</span><span class="p">(</span><span class="n">batch_size</span><span class="o">=</span><span class="n">chunk_size</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="n">columns_to_read</span><span class="p">):</span>
        <span class="k">yield</span> <span class="n">chunk</span><span class="o">.</span><span class="n">to_pandas</span><span class="p">()</span></div>

<div class="viewcode-block" id="check_input_file"><a class="viewcode-back" href="../../code/uesgraphs.html#uesgraphs.analyze.check_input_file">[docs]</a><span class="k">def</span><span class="w"> </span><span class="nf">check_input_file</span><span class="p">(</span><span class="n">file_path</span><span class="p">):</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">file_path</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;File path cannot be empty&quot;</span><span class="p">)</span>

    <span class="n">base_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">splitext</span><span class="p">(</span><span class="n">file_path</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">gzip_path</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">base_path</span><span class="si">}</span><span class="s2">.gzip&quot;</span>

    <span class="c1"># Check for gzip first</span>
    <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">gzip_path</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">gzip_path</span>
    <span class="c1"># Then check for .mat</span>
    <span class="n">mat_path</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">base_path</span><span class="si">}</span><span class="s2">.mat&quot;</span>
    <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">mat_path</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Converting .mat file to parquet: </span><span class="si">{</span><span class="n">mat_path</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">gzip_new</span> <span class="o">=</span> <span class="n">mat_to_parquet</span><span class="p">(</span><span class="n">save_as</span> <span class="o">=</span> <span class="n">base_path</span><span class="p">,</span> <span class="n">fname</span> <span class="o">=</span> <span class="n">mat_path</span><span class="p">,</span><span class="n">with_unit</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Converted .mat file to parquet: </span><span class="si">{</span><span class="n">gzip_new</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">gzip_new</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Could not convert .mat file to parquet: </span><span class="si">{</span><span class="n">mat_path</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span> 
    <span class="c1"># Finally check if file exists with any extension</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">file_path</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;File does not exist: </span><span class="si">{</span><span class="n">file_path</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="process_simulation_result"><a class="viewcode-back" href="../../code/uesgraphs.html#uesgraphs.analyze.process_simulation_result">[docs]</a><span class="k">def</span><span class="w"> </span><span class="nf">process_simulation_result</span><span class="p">(</span><span class="n">file_path</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">filter_list</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Process a single simulation result file and return the processed DataFrame.</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        file_path: Complete path to the simulation result file</span>
<span class="sd">        filter_list: List of column patterns to filter</span>
<span class="sd">        </span>
<span class="sd">    Returns:</span>
<span class="sd">        pd.DataFrame: Processed and filtered DataFrame from the simulation results</span>
<span class="sd">        </span>
<span class="sd">    Raises:</span>
<span class="sd">        FileNotFoundError: If the specified file does not exist</span>
<span class="sd">        ValueError: If the file path is empty or invalid</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">file_path</span> <span class="o">=</span> <span class="n">check_input_file</span><span class="p">(</span><span class="n">file_path</span><span class="o">=</span><span class="n">file_path</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Processing: </span><span class="si">{</span><span class="n">file_path</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    
    <span class="c1"># Initialize an empty list for filtered chunks</span>
    <span class="n">filtered_chunks</span> <span class="o">=</span> <span class="p">[]</span>
    
    <span class="c1"># Process the file in chunks</span>
    <span class="k">for</span> <span class="n">chunk</span> <span class="ow">in</span> <span class="n">process_parquet_file</span><span class="p">(</span><span class="n">file_path</span><span class="p">,</span> <span class="n">filter_list</span><span class="p">):</span>
        <span class="n">filtered_chunks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">chunk</span><span class="p">)</span>
    
    <span class="c1"># Combine all chunks into a single DataFrame</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">filtered_chunks</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">()</span>  <span class="c1"># Return empty DataFrame if no data was processed</span>
        
    <span class="n">result_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">(</span><span class="n">filtered_chunks</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    
    <span class="c1"># Clear the chunks list to free memory</span>
    <span class="n">filtered_chunks</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
    
    <span class="k">return</span> <span class="n">result_df</span></div>

<span class="c1">#### Functions 3: Data Processing ####</span>

<div class="viewcode-block" id="prepare_DataFrame"><a class="viewcode-back" href="../../code/uesgraphs.html#uesgraphs.analyze.prepare_DataFrame">[docs]</a><span class="k">def</span><span class="w"> </span><span class="nf">prepare_DataFrame</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">base_date</span><span class="o">=</span><span class="n">datetime</span><span class="p">(</span><span class="mi">2024</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span><span class="n">time_interval</span><span class="o">=</span><span class="s2">&quot;15min&quot;</span><span class="p">,</span><span class="n">start_date</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">end_date</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Prepare a DataFrame with a datetime index using customizable parameters.</span>
<span class="sd">    </span>
<span class="sd">    Parameters:</span>
<span class="sd">    -----------</span>
<span class="sd">    df : pandas.DataFrame</span>
<span class="sd">        The DataFrame to be processed</span>
<span class="sd">    base_date : datetime, optional</span>
<span class="sd">        The starting date for the index (default: 2024-01-01)</span>
<span class="sd">    time_interval : str, optional</span>
<span class="sd">        Frequency of the time intervals (e.g., &#39;15min&#39;, &#39;1h&#39;, &#39;30min&#39;, default: &#39;15min&#39;)</span>
<span class="sd">    start_date : datetime, optional</span>
<span class="sd">        If provided, slice the DataFrame from this date (inclusive)</span>
<span class="sd">    end_date : datetime, optional</span>
<span class="sd">        If provided, slice the DataFrame until this date (inclusive)</span>
<span class="sd">    </span>
<span class="sd">    Returns:</span>
<span class="sd">   </span>
<span class="sd">    DataFrame: A DataFrame containing the data from the parquet file for the specified time period.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="c1"># Create datetime index with specified frequency    </span>
        <span class="n">datetime_index</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">date_range</span><span class="p">(</span><span class="n">start</span><span class="o">=</span><span class="n">base_date</span><span class="p">,</span> <span class="n">periods</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">df</span><span class="p">),</span> <span class="n">freq</span><span class="o">=</span><span class="n">time_interval</span><span class="p">)</span>
        
        <span class="c1"># Set the index of the DataFrame to the datetime index</span>
        <span class="n">df</span><span class="o">.</span><span class="n">index</span> <span class="o">=</span> <span class="n">datetime_index</span>

        <span class="c1">#Filter by data_range if specified</span>
        <span class="k">if</span> <span class="n">start_date</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">end_date</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">start_date</span><span class="p">:</span><span class="n">end_date</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">start_date</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">start_date</span><span class="p">:]</span>
        <span class="k">elif</span> <span class="n">end_date</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[:</span><span class="n">end_date</span><span class="p">]</span>
        <span class="c1"># Benenne den Index um</span>
        <span class="n">df</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;DateTime&#39;</span>

        <span class="k">return</span> <span class="n">df</span>
    <span class="k">except</span> <span class="ne">ValueError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Error create data range with frequency </span><span class="si">{</span><span class="n">time_interval</span><span class="si">}</span><span class="s2"> and base date </span><span class="si">{</span><span class="n">base_date</span><span class="si">}</span><span class="s2">.&quot;</span>
                         <span class="sa">f</span><span class="s2">&quot;Original error: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span> </div>

<div class="viewcode-block" id="get_mostfrequent_value"><a class="viewcode-back" href="../../code/uesgraphs.html#uesgraphs.analyze.get_mostfrequent_value">[docs]</a><span class="k">def</span><span class="w"> </span><span class="nf">get_mostfrequent_value</span><span class="p">(</span><span class="n">liste</span><span class="p">):</span>
    <span class="c1">#Find unique values and frequencies</span>
    <span class="n">unique_values</span><span class="p">,</span> <span class="n">counts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">liste</span><span class="p">,</span> <span class="n">return_counts</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="c1">#Find index of most frequent value and save that value</span>
    <span class="n">max_index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">counts</span><span class="p">)</span>
    <span class="n">result</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">unique_values</span><span class="p">[</span><span class="n">max_index</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">result</span></div>

<div class="viewcode-block" id="get_peripheral_value"><a class="viewcode-back" href="../../code/uesgraphs.html#uesgraphs.analyze.get_peripheral_value">[docs]</a><span class="k">def</span><span class="w"> </span><span class="nf">get_peripheral_value</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">edge</span><span class="p">,</span> <span class="n">heating_network</span><span class="p">,</span> <span class="n">param</span><span class="p">,</span> <span class="n">value_a</span><span class="p">,</span> <span class="n">value_b</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">node2</span> <span class="ow">in</span> <span class="n">edge</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">node2</span> <span class="o">!=</span> <span class="n">node</span><span class="p">:</span>
            <span class="n">value_assigned_node</span> <span class="o">=</span> <span class="n">heating_network</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">node2</span><span class="p">][</span><span class="n">param</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">value_a</span> <span class="o">-</span> <span class="n">value_assigned_node</span><span class="p">)</span> <span class="o">&lt;</span> <span class="nb">abs</span><span class="p">(</span><span class="n">value_b</span> <span class="o">-</span> <span class="n">value_assigned_node</span><span class="p">):</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">value_b</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">value_a</span>
    <span class="k">return</span> <span class="n">result</span></div>

<div class="viewcode-block" id="get_node_values"><a class="viewcode-back" href="../../code/uesgraphs.html#uesgraphs.analyze.get_node_values">[docs]</a><span class="k">def</span><span class="w"> </span><span class="nf">get_node_values</span><span class="p">(</span><span class="n">heating_network</span><span class="p">,</span> <span class="n">row</span><span class="p">,</span><span class="n">pipe_type</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">):</span>
    <span class="n">nodes</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">heating_network</span><span class="o">.</span><span class="n">nodes</span><span class="p">)</span>
    <span class="n">assigned_nodes</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">nodes_peripheral</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="c1">#Neighbor-algorihm: find the most frequent value at a node where at least 2 edges meet</span>
    <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">nodes</span><span class="p">:</span>         
        <span class="n">edges</span> <span class="o">=</span>  <span class="n">heating_network</span><span class="o">.</span><span class="n">edges</span><span class="p">(</span><span class="n">node</span><span class="p">)</span> <span class="c1">#Find adjacent edges</span>
        <span class="c1">#If we find only one edge we are regarding a peripheral node, which cant be solved by the neigbor algorithm</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">edges</span><span class="p">)</span><span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">pressures</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">temperatures</span><span class="o">=</span><span class="p">[]</span>

            <span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="n">edges</span><span class="p">:</span>
                <span class="n">pipe_name</span><span class="o">=</span> <span class="n">heating_network</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="n">edge</span><span class="p">][</span><span class="s1">&#39;name&#39;</span><span class="p">]</span>
                <span class="n">pressure_a</span> <span class="o">=</span> <span class="n">row</span><span class="p">[</span><span class="n">MASKS</span><span class="p">[</span><span class="s2">&quot;p_a&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">pipe_code</span><span class="o">=</span><span class="n">pipe_name</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="n">pipe_type</span><span class="p">)]</span>
                <span class="n">pressure_b</span> <span class="o">=</span> <span class="n">row</span><span class="p">[</span><span class="n">MASKS</span><span class="p">[</span><span class="s2">&quot;p_b&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">pipe_code</span><span class="o">=</span><span class="n">pipe_name</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="n">pipe_type</span><span class="p">)]</span>

                <span class="n">temperature_a</span> <span class="o">=</span> <span class="n">row</span><span class="p">[</span><span class="n">MASKS</span><span class="p">[</span><span class="s2">&quot;T_a&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">pipe_code</span><span class="o">=</span><span class="n">pipe_name</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="n">pipe_type</span><span class="p">)]</span>
                <span class="n">temperature_b</span> <span class="o">=</span> <span class="n">row</span><span class="p">[</span><span class="n">MASKS</span><span class="p">[</span><span class="s2">&quot;T_b&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">pipe_code</span><span class="o">=</span><span class="n">pipe_name</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="n">pipe_type</span><span class="p">)]</span>

                <span class="n">pressures</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="n">pressure_a</span><span class="p">,</span> <span class="n">pressure_b</span><span class="p">])</span>
                <span class="n">temperatures</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="n">temperature_a</span><span class="p">,</span><span class="n">temperature_b</span><span class="p">])</span>
            <span class="n">pressure</span> <span class="o">=</span> <span class="n">get_mostfrequent_value</span><span class="p">(</span><span class="n">pressures</span><span class="p">)</span>
            <span class="n">temperature</span> <span class="o">=</span> <span class="n">get_mostfrequent_value</span><span class="p">(</span><span class="n">temperatures</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">pressure_a</span> <span class="o">==</span> <span class="n">pressure</span><span class="p">:</span>
                <span class="n">heating_network</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">node</span><span class="p">][</span><span class="s2">&quot;press_name&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">MASKS</span><span class="p">[</span><span class="s2">&quot;p_a&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">pipe_code</span><span class="o">=</span><span class="n">pipe_name</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="n">pipe_type</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">pressure_b</span> <span class="o">==</span> <span class="n">pressure</span><span class="p">:</span>
                <span class="n">heating_network</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">node</span><span class="p">][</span><span class="s2">&quot;press_name&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">MASKS</span><span class="p">[</span><span class="s2">&quot;p_b&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">pipe_code</span><span class="o">=</span><span class="n">pipe_name</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="n">pipe_type</span><span class="p">)</span>
            <span class="n">heating_network</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">node</span><span class="p">][</span><span class="s2">&quot;press_flow&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">pressure</span>

            <span class="k">if</span> <span class="n">temperature_a</span> <span class="o">==</span> <span class="n">temperature</span><span class="p">:</span>
                <span class="n">heating_network</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">node</span><span class="p">][</span><span class="s2">&quot;temp_name&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">MASKS</span><span class="p">[</span><span class="s2">&quot;T_a&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">pipe_code</span><span class="o">=</span><span class="n">pipe_name</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="n">pipe_type</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">temperature_b</span> <span class="o">==</span> <span class="n">temperature</span><span class="p">:</span>
                <span class="n">heating_network</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">node</span><span class="p">][</span><span class="s2">&quot;temp_name&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">MASKS</span><span class="p">[</span><span class="s2">&quot;T_b&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">pipe_code</span><span class="o">=</span><span class="n">pipe_name</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="n">pipe_type</span><span class="p">)</span>
            <span class="n">heating_network</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">node</span><span class="p">][</span><span class="s2">&quot;temperature_supply&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">temperature</span>
            <span class="n">assigned_nodes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">nodes_peripheral</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
    <span class="c1">#Peripheral-algorithm: Takes the not solved nodes from the neighbor-algorithm. Since we&#39;re still not sure</span>
            <span class="c1"># if the port_a or ports_b value is the right one, we compare the simulation results with the already assigned node</span>
            <span class="c1"># that was solved by the neighbor-algorithm.</span>
    <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">nodes_peripheral</span><span class="p">:</span>
        <span class="n">edge</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">heating_network</span><span class="o">.</span><span class="n">edges</span><span class="p">(</span><span class="n">node</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">pipe_name</span> <span class="o">=</span> <span class="n">heating_network</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="n">edge</span><span class="p">][</span><span class="s2">&quot;name&quot;</span><span class="p">]</span>
        <span class="n">pressure_a</span> <span class="o">=</span> <span class="n">row</span><span class="p">[</span><span class="n">MASKS</span><span class="p">[</span><span class="s2">&quot;p_a&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">pipe_code</span><span class="o">=</span><span class="n">pipe_name</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="n">pipe_type</span><span class="p">)]</span>
        <span class="n">pressure_b</span> <span class="o">=</span> <span class="n">row</span><span class="p">[</span><span class="n">MASKS</span><span class="p">[</span><span class="s2">&quot;p_b&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">pipe_code</span><span class="o">=</span><span class="n">pipe_name</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="n">pipe_type</span><span class="p">)]</span>

        <span class="n">temperature_a</span> <span class="o">=</span> <span class="n">row</span><span class="p">[</span><span class="n">MASKS</span><span class="p">[</span><span class="s2">&quot;T_a&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">pipe_code</span><span class="o">=</span><span class="n">pipe_name</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="n">pipe_type</span><span class="p">)]</span>
        <span class="n">temperature_b</span> <span class="o">=</span> <span class="n">row</span><span class="p">[</span><span class="n">MASKS</span><span class="p">[</span><span class="s2">&quot;T_b&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">pipe_code</span><span class="o">=</span><span class="n">pipe_name</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="n">pipe_type</span><span class="p">)]</span>
        
        <span class="n">pressure</span> <span class="o">=</span> <span class="n">get_peripheral_value</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">edge</span><span class="p">,</span> <span class="n">heating_network</span><span class="p">,</span> <span class="s2">&quot;press_flow&quot;</span><span class="p">,</span> <span class="n">pressure_a</span><span class="p">,</span> <span class="n">pressure_b</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">pressure_a</span> <span class="o">==</span> <span class="n">pressure</span><span class="p">:</span>
            <span class="n">heating_network</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">node</span><span class="p">][</span><span class="s2">&quot;press_name&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">MASKS</span><span class="p">[</span><span class="s2">&quot;p_a&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">pipe_code</span><span class="o">=</span><span class="n">pipe_name</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="n">pipe_type</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">pressure_b</span> <span class="o">==</span> <span class="n">pressure</span><span class="p">:</span>
            <span class="n">heating_network</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">node</span><span class="p">][</span><span class="s2">&quot;press_name&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">MASKS</span><span class="p">[</span><span class="s2">&quot;p_b&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">pipe_code</span><span class="o">=</span><span class="n">pipe_name</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="n">pipe_type</span><span class="p">)</span>
        <span class="n">heating_network</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">node</span><span class="p">][</span><span class="s2">&quot;press_flow&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">pressure</span>

        <span class="n">temperature</span> <span class="o">=</span> <span class="n">get_peripheral_value</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">edge</span><span class="p">,</span> <span class="n">heating_network</span><span class="p">,</span> <span class="s2">&quot;temperature_supply&quot;</span><span class="p">,</span> <span class="n">temperature_a</span><span class="p">,</span> <span class="n">temperature_b</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">temperature_a</span> <span class="o">==</span> <span class="n">temperature</span><span class="p">:</span>
            <span class="n">heating_network</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">node</span><span class="p">][</span><span class="s2">&quot;temp_name&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">MASKS</span><span class="p">[</span><span class="s2">&quot;T_a&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">pipe_code</span><span class="o">=</span><span class="n">pipe_name</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="n">pipe_type</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">temperature_b</span> <span class="o">==</span> <span class="n">temperature</span><span class="p">:</span>
            <span class="n">heating_network</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">node</span><span class="p">][</span><span class="s2">&quot;temp_name&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">MASKS</span><span class="p">[</span><span class="s2">&quot;T_b&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">pipe_code</span><span class="o">=</span><span class="n">pipe_name</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="n">pipe_type</span><span class="p">)</span>
        <span class="n">heating_network</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">node</span><span class="p">][</span><span class="s2">&quot;temperature_supply&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">temperature</span>
        
        <span class="n">assigned_nodes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
    
    <span class="c1">####Assert</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">assigned_nodes</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">nodes</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Assignment of pressure to nodes completed&quot;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Assignmnet failed -- severe </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">assigned_nodes</span><span class="p">)</span><span class="si">}</span><span class="s2"> und </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">nodes</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">heating_network</span></div>

<div class="viewcode-block" id="check_supply_type"><a class="viewcode-back" href="../../code/uesgraphs.html#uesgraphs.analyze.check_supply_type">[docs]</a><span class="k">def</span><span class="w"> </span><span class="nf">check_supply_type</span><span class="p">(</span><span class="n">graph</span><span class="p">):</span>
    <span class="c1"># Check if the graph is a supply or return graph</span>
    <span class="k">if</span> <span class="s2">&quot;supply_type&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">graph</span><span class="o">.</span><span class="n">graph</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The graph does not have a supply_type attribute&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">graph</span><span class="o">.</span><span class="n">graph</span><span class="p">[</span><span class="s2">&quot;supply_type&quot;</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;supply&quot;</span><span class="p">,</span> <span class="s2">&quot;return&quot;</span><span class="p">]:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The graph supply_type attribute must be either &#39;supply&#39; or &#39;return&#39;&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">graph</span><span class="o">.</span><span class="n">graph</span><span class="p">[</span><span class="s2">&quot;supply_type&quot;</span><span class="p">]</span></div>

<div class="viewcode-block" id="get_MASKS"><a class="viewcode-back" href="../../code/uesgraphs.html#uesgraphs.analyze.get_MASKS">[docs]</a><span class="k">def</span><span class="w"> </span><span class="nf">get_MASKS</span><span class="p">(</span><span class="n">aixlib_version</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Returns the correct variable masks for different AixLib versions.</span>
<span class="sd">    </span>
<span class="sd">    The naming convention for variables in the simulation model depends on the AixLib version</span>
<span class="sd">    used to build it. The key difference is in how ports are referenced:</span>
<span class="sd">    - Version 2.1.0: Uses direct port access (e.g., port_b.p)</span>
<span class="sd">    - Earlier versions: Uses array indexing for ports_b (e.g., ports_b[1].p)</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        aixlib_version: Version string of AixLib used to build the model</span>
<span class="sd">        </span>
<span class="sd">    Returns:</span>
<span class="sd">        Dictionary mapping variable types to their full path in the simulation model</span>
<span class="sd">        </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">aixlib_version</span> <span class="o">==</span> <span class="s2">&quot;2.1.0&quot;</span><span class="p">:</span>
        <span class="n">masks</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;m_flow&quot;</span><span class="p">:</span> <span class="s2">&quot;networkModel.pipe</span><span class="si">{pipe_code}{type}</span><span class="s2">.port_a.m_flow&quot;</span><span class="p">,</span>
         <span class="s2">&quot;dp&quot;</span><span class="p">:</span> <span class="s2">&quot;networkModel.pipe</span><span class="si">{pipe_code}{type}</span><span class="s2">.dp&quot;</span><span class="p">,</span>
         <span class="s2">&quot;p_a&quot;</span><span class="p">:</span> <span class="s2">&quot;networkModel.pipe</span><span class="si">{pipe_code}{type}</span><span class="s2">.port_a.p&quot;</span><span class="p">,</span>
         <span class="s2">&quot;p_b&quot;</span><span class="p">:</span> <span class="s2">&quot;networkModel.pipe</span><span class="si">{pipe_code}{type}</span><span class="s2">.port_b.p&quot;</span><span class="p">,</span>
         <span class="s2">&quot;T_a&quot;</span><span class="p">:</span> <span class="s2">&quot;networkModel.pipe</span><span class="si">{pipe_code}{type}</span><span class="s2">.sta_a.T&quot;</span><span class="p">,</span>
         <span class="s2">&quot;T_b&quot;</span><span class="p">:</span> <span class="s2">&quot;networkModel.pipe</span><span class="si">{pipe_code}{type}</span><span class="s2">.sta_b.T&quot;</span><span class="p">,</span>
         <span class="p">}</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">masks</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;m_flow&quot;</span><span class="p">:</span> <span class="s2">&quot;networkModel.pipe</span><span class="si">{pipe_code}{type}</span><span class="s2">.port_a.m_flow&quot;</span><span class="p">,</span>
         <span class="s2">&quot;p_a&quot;</span><span class="p">:</span> <span class="s2">&quot;networkModel.pipe</span><span class="si">{pipe_code}{type}</span><span class="s2">.port_a.p&quot;</span><span class="p">,</span>
         <span class="s2">&quot;p_b&quot;</span><span class="p">:</span> <span class="s2">&quot;networkModel.pipe</span><span class="si">{pipe_code}{type}</span><span class="s2">.ports_b[1].p&quot;</span><span class="p">,</span>
         <span class="s2">&quot;T_a&quot;</span><span class="p">:</span> <span class="s2">&quot;networkModel.pipe</span><span class="si">{pipe_code}{type}</span><span class="s2">.sta_a.T&quot;</span><span class="p">,</span>
         <span class="s2">&quot;T_b&quot;</span><span class="p">:</span> <span class="s2">&quot;networkModel.pipe</span><span class="si">{pipe_code}{type}</span><span class="s2">.sta_b[1].T&quot;</span><span class="p">,</span>
         <span class="p">}</span>
    <span class="k">return</span> <span class="n">masks</span></div>


<span class="c1">#### Functions 4: Data Assignment (main) ####</span>

<div class="viewcode-block" id="assign_data_to_uesgraphs"><a class="viewcode-back" href="../../code/uesgraphs.html#uesgraphs.analyze.assign_data_to_uesgraphs">[docs]</a><span class="k">def</span><span class="w"> </span><span class="nf">assign_data_to_uesgraphs</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span><span class="n">sim_data</span><span class="p">,</span><span class="n">start_date</span><span class="p">,</span><span class="n">end_date</span><span class="p">,</span> <span class="n">aixlib_version</span> <span class="o">=</span><span class="s2">&quot;2.1.0&quot;</span><span class="p">,</span><span class="n">time_interval</span><span class="o">=</span><span class="s2">&quot;15min&quot;</span><span class="p">):</span>
    
    <span class="n">check_supply_type</span><span class="p">(</span><span class="n">graph</span><span class="p">)</span> <span class="c1"># Check if the graph is a supply or return graph</span>

    <span class="n">supply_type_prefix</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;supply&quot;</span><span class="p">:</span> <span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="s2">&quot;return&quot;</span><span class="p">:</span> <span class="s2">&quot;R&quot;</span><span class="p">}</span>

    <span class="k">global</span> <span class="n">MASKS</span>
    <span class="n">MASKS</span> <span class="o">=</span> <span class="n">get_MASKS</span><span class="p">(</span><span class="n">aixlib_version</span><span class="p">)</span>
    <span class="k">try</span><span class="p">:</span>

        <span class="n">filter_list</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="n">graph</span><span class="o">.</span><span class="n">edges</span><span class="p">:</span>
            <span class="n">pipe_code</span> <span class="o">=</span> <span class="n">graph</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="n">edge</span><span class="p">][</span><span class="s2">&quot;name&quot;</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">mask</span> <span class="ow">in</span> <span class="n">MASKS</span><span class="p">:</span>
                <span class="n">filter_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">MASKS</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">pipe_code</span><span class="o">=</span><span class="n">pipe_code</span><span class="p">,</span> 
                                                    <span class="nb">type</span><span class="o">=</span><span class="n">supply_type_prefix</span><span class="p">[</span><span class="n">graph</span><span class="o">.</span><span class="n">graph</span><span class="p">[</span><span class="s2">&quot;supply_type&quot;</span><span class="p">]]))</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">process_simulation_result</span><span class="p">(</span><span class="n">file_path</span><span class="o">=</span><span class="n">sim_data</span><span class="p">,</span> <span class="n">filter_list</span><span class="o">=</span><span class="n">filter_list</span><span class="p">)</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">prepare_DataFrame</span><span class="p">(</span><span class="n">df</span><span class="p">,</span><span class="n">start_date</span><span class="o">=</span><span class="n">start_date</span><span class="p">,</span> <span class="n">end_date</span><span class="o">=</span><span class="n">end_date</span><span class="p">,</span><span class="n">time_interval</span><span class="o">=</span><span class="n">time_interval</span><span class="p">)</span>
        
        <span class="n">graph</span> <span class="o">=</span> <span class="n">get_node_values</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">df</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">pipe_type</span><span class="o">=</span><span class="n">supply_type_prefix</span><span class="p">[</span><span class="n">graph</span><span class="o">.</span><span class="n">graph</span><span class="p">[</span><span class="s2">&quot;supply_type&quot;</span><span class="p">]])</span>
        
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">graph</span><span class="o">.</span><span class="n">nodes</span><span class="p">:</span>
            <span class="n">graph</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">node</span><span class="p">][</span><span class="s2">&quot;press_flow&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="n">graph</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">node</span><span class="p">][</span><span class="s2">&quot;press_name&quot;</span><span class="p">]]</span>
            <span class="n">graph</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">node</span><span class="p">][</span><span class="s2">&quot;temperature_supply&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="n">graph</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">node</span><span class="p">][</span><span class="s2">&quot;temp_name&quot;</span><span class="p">]]</span>
        
        <span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="n">graph</span><span class="o">.</span><span class="n">edges</span><span class="p">:</span>
            <span class="n">graph</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="n">edge</span><span class="p">][</span><span class="s2">&quot;m_flow&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="n">MASKS</span><span class="p">[</span><span class="s2">&quot;m_flow&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">pipe_code</span><span class="o">=</span><span class="n">graph</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="n">edge</span><span class="p">][</span><span class="s2">&quot;name&quot;</span><span class="p">],</span>
                                                                <span class="nb">type</span><span class="o">=</span><span class="n">supply_type_prefix</span><span class="p">[</span><span class="n">graph</span><span class="o">.</span><span class="n">graph</span><span class="p">[</span><span class="s2">&quot;supply_type&quot;</span><span class="p">]])]</span>
            <span class="c1">#graph.edges[edge][&quot;press_drop&quot;] = abs(graph.nodes[edge[0]][&quot;press_flow&quot;] - graph.nodes[edge[1]][&quot;press_flow&quot;])</span>
            <span class="c1">#graph.edges[edge][&quot;press_drop_length&quot;] = graph.edges[edge][&quot;press_drop&quot;] / graph.edges[edge][&quot;length&quot;]</span>
            <span class="n">dp</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="n">MASKS</span><span class="p">[</span><span class="s2">&quot;dp&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">pipe_code</span><span class="o">=</span><span class="n">graph</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="n">edge</span><span class="p">][</span><span class="s2">&quot;name&quot;</span><span class="p">],</span><span class="nb">type</span><span class="o">=</span><span class="n">supply_type_prefix</span><span class="p">[</span><span class="n">graph</span><span class="o">.</span><span class="n">graph</span><span class="p">[</span><span class="s2">&quot;supply_type&quot;</span><span class="p">]])]</span>
            <span class="n">graph</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="n">edge</span><span class="p">][</span><span class="s2">&quot;press_drop&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">dp</span><span class="p">)</span>
            <span class="c1">#graph.edges[edge][&quot;temp_diff&quot;] = abs(graph.nodes[edge[0]][&quot;temperature_supply&quot;] - graph.nodes[edge[1]][&quot;temperature_supply&quot;])</span>
    <span class="k">except</span> <span class="ne">KeyError</span> <span class="k">as</span> <span class="n">e_key</span><span class="p">:</span>
        <span class="k">if</span> <span class="s2">&quot;ports_b[1]&quot;</span> <span class="ow">in</span> <span class="nb">str</span><span class="p">(</span><span class="n">e_key</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Key: </span><span class="si">{</span><span class="n">e_key</span><span class="si">}</span><span class="s2">  not found in data.&quot;</span>
                  <span class="s1">&#39;Try using aixlib_version=&quot;2.1.0&quot; when calling assign_data_to_uesgraphs&#39;</span>
                  <span class="s2">&quot;For more information see method get_MASKS(aixlib_version) in analyze.py&quot;</span>
            <span class="p">)</span> <span class="kn">from</span><span class="w"> </span><span class="nn">e_key</span>
        <span class="k">elif</span> <span class="s2">&quot;port_b&quot;</span> <span class="ow">in</span> <span class="nb">str</span><span class="p">(</span><span class="n">e_key</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Key: </span><span class="si">{</span><span class="n">e_key</span><span class="si">}</span><span class="s2">  not found in data.&quot;</span>
                           <span class="s1">&#39;Try using aixlib_version=&quot;2.0.0&quot; when calling assign_data_to_uesgraphs&#39;</span>
                  <span class="s2">&quot; For more information see method get_MASKS(aixlib_version) in analyze.py&quot;</span>
            <span class="p">)</span> <span class="kn">from</span><span class="w"> </span><span class="nn">e_key</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Key: </span><span class="si">{</span><span class="n">e_key</span><span class="si">}</span><span class="s2">  not found in data.&quot;</span>
                  <span class="s2">&quot;Unknown Error. Check your data if it complies with mapping of get_MASKS(aixlib_version) in analyze.py&quot;</span>
            <span class="p">)</span> <span class="kn">from</span><span class="w"> </span><span class="nn">e_key</span>
    <span class="k">return</span> <span class="n">graph</span></div>


<span class="c1">#### Functions 5: Data post-processing ####</span>

<span class="c1">## Functions 5.1: Pump Power Analysis</span>

<div class="viewcode-block" id="pump_power_analysis"><a class="viewcode-back" href="../../code/uesgraphs.html#uesgraphs.analyze.pump_power_analysis">[docs]</a><span class="k">def</span><span class="w"> </span><span class="nf">pump_power_analysis</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">plot</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">output_dir</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">config</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Perform a complete pump power and energy analysis for a district heating network.</span>
<span class="sd">    </span>
<span class="sd">    This function orchestrates the full pump analysis workflow by calculating the required </span>
<span class="sd">    pump power, converting it to energy consumption over time, optionally plotting the </span>
<span class="sd">    results, and saving the data to a file if specified.</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    graph : uesgraphs.UESGraph</span>
<span class="sd">        A graph representation of the heating network with hydraulic attributes.</span>
<span class="sd">    plot : bool, default=True</span>
<span class="sd">        Whether to generate visualizations of the pump energy consumption.</span>
<span class="sd">    output_dir : str or Path, optional</span>
<span class="sd">        Directory path where outputs (plots and CSV files) should be saved.</span>
<span class="sd">        If None, results are not saved to disk.</span>
<span class="sd">    config : dict, optional</span>
<span class="sd">        Configuration parameters for pump power calculations including efficiency factors</span>
<span class="sd">        and operational settings.</span>
<span class="sd">    </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    pandas.DataFrame</span>
<span class="sd">        DataFrame containing time series of pump energy consumption with timestamps as index.</span>
<span class="sd">    </span>
<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    - The function requires proper hydraulic attributes in the graph (pressure drops, flows)</span>
<span class="sd">    - The returned DataFrame includes columns for energy consumption in different units</span>
<span class="sd">    - When saving results, the function creates &#39;pump_energy.csv&#39; in the output_dir</span>
<span class="sd">    - The plotting and saving operations are skipped if the respective parameters are not provided</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Step 1: Calculate pump power requirements</span>
    <span class="n">graph</span><span class="p">,</span> <span class="n">pump_power_df</span> <span class="o">=</span> <span class="n">calculate_central_pump_power</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">config</span><span class="p">)</span>
    
    <span class="c1"># Step 2: Convert power to energy consumption over time</span>
    <span class="n">pump_energy_df</span> <span class="o">=</span> <span class="n">calculate_pump_energy</span><span class="p">(</span><span class="n">pump_power_df</span><span class="p">)</span>
    
    <span class="c1"># Step 3: Generate visualizations if requested</span>
    <span class="k">if</span> <span class="n">plot</span><span class="p">:</span>
        <span class="n">plot_pump_energy</span><span class="p">(</span><span class="n">pump_energy_df</span><span class="p">,</span> <span class="n">output_dir</span><span class="p">)</span>
    
    <span class="c1"># Step 4: Save results to disk if output directory is specified</span>
    <span class="k">if</span> <span class="n">output_dir</span><span class="p">:</span>
        <span class="n">pump_energy_df</span><span class="o">.</span><span class="n">to_csv</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">output_dir</span><span class="p">,</span> <span class="s2">&quot;pump_energy.csv&quot;</span><span class="p">),</span> <span class="n">index</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">pump_energy_df</span></div>

<div class="viewcode-block" id="calculate_central_pump_power"><a class="viewcode-back" href="../../code/uesgraphs.html#uesgraphs.analyze.calculate_central_pump_power">[docs]</a><span class="k">def</span><span class="w"> </span><span class="nf">calculate_central_pump_power</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">config</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculate pump power requirements for a district heating network.</span>
<span class="sd">    </span>
<span class="sd">    This function analyzes a heating network graph to determine the required pump power </span>
<span class="sd">    based on hydraulic pressure drops, flow rates, and pump configuration parameters.</span>
<span class="sd">    It performs time series analysis for each timestamp in the network data.</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    graph : ug.UESGraph</span>
<span class="sd">        A graph representation of the heating network with hydraulic attributes.</span>
<span class="sd">        Must contain time series data for pressure drops and mass flow rates.</span>
<span class="sd">    config : dict, optional</span>
<span class="sd">        Configuration dictionary with the following keys:</span>
<span class="sd">        - eta_pump: float, pump efficiency factor (default: 0.8)</span>
<span class="sd">        - dp_pump: float, internal pump pressure drop in Pa (default: 1000)</span>
<span class="sd">        - density_func: callable or float, water density function or constant value</span>
<span class="sd">          If callable, must accept timestamp and temperature parameters</span>
<span class="sd">    </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    tuple</span>
<span class="sd">        A tuple containing:</span>
<span class="sd">        - The original graph with potentially modified attributes</span>
<span class="sd">        - pandas.DataFrame with time series of pump power calculations including:</span>
<span class="sd">          * timestamp: time index</span>
<span class="sd">          * source_node: ID of the supply node</span>
<span class="sd">          * max_pressure_node: node with maximum pressure drop</span>
<span class="sd">          * max_pressure_value: maximum pressure drop value in Pa</span>
<span class="sd">          * dp_tot: total pressure drop in Pa (including return pipe and pump)</span>
<span class="sd">          * volume_flow: volume flow rate in m/s</span>
<span class="sd">          * pump_power: calculated pump power in kW</span>
<span class="sd">          * rho: water density in kg/m</span>
<span class="sd">          * eta_pump: pump efficiency factor</span>
<span class="sd">          * dp_pump: internal pump pressure drop in Pa</span>
<span class="sd">          * pressure_*: accumulated pressure to each node</span>
<span class="sd">    </span>
<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    TypeError</span>
<span class="sd">        If the provided graph is not an instance of UESGraph</span>
<span class="sd">    </span>
<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    - Currently supports only one supply node in the network</span>
<span class="sd">    - Assumes symmetric pressure drops in supply and return pipes</span>
<span class="sd">    - Uses the formula: P = (dp_tot * V_dot) / (eta_pump * 1000)</span>
<span class="sd">    - Where dp_tot = 2 * max_pressure_value + dp_pump</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">ug</span><span class="o">.</span><span class="n">UESGraph</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;graph must be an instance of UESGraph&quot;</span><span class="p">)</span>
    
    <span class="c1"># Default configuration parameters</span>
    <span class="n">default_config</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s2">&quot;eta_pump&quot;</span><span class="p">:</span> <span class="mf">0.8</span><span class="p">,</span>                            <span class="c1"># Default pump efficiency</span>
        <span class="s2">&quot;dp_pump&quot;</span><span class="p">:</span> <span class="mi">1000</span><span class="p">,</span>                            <span class="c1"># Default internal pump pressure drop [Pa]</span>
        <span class="s2">&quot;density_func&quot;</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">t</span><span class="p">,</span> <span class="n">temp</span><span class="o">=</span><span class="kc">None</span><span class="p">:</span> <span class="mi">998</span>    <span class="c1"># Default density function for water at 20C [kg/m]</span>
    <span class="p">}</span>

    <span class="c1"># Initialize configuration with defaults</span>
    <span class="k">if</span> <span class="n">config</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">config</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="c1"># Merge provided configuration with defaults</span>
    <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">default_config</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">config</span><span class="p">:</span>
            <span class="n">config</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>

    <span class="c1"># Store results in a list</span>
    <span class="n">results</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="c1"># Start algorithm by finding supply nodes</span>
    <span class="n">source_nodes</span><span class="p">,</span> <span class="n">source_edges</span> <span class="o">=</span> <span class="n">find_source_nodes</span><span class="p">(</span><span class="n">graph</span><span class="p">)</span>

    <span class="c1"># Process each supply node in the network</span>
    <span class="c1"># Note: Currently only one supply node is fully supported</span>
    <span class="k">for</span> <span class="n">source_node</span> <span class="ow">in</span> <span class="n">source_nodes</span><span class="p">:</span>
        <span class="c1"># Get time index from the pressure drop time series of the source edge</span>
        <span class="n">time_index</span> <span class="o">=</span> <span class="n">graph</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="n">source_edges</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="s2">&quot;press_drop&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">index</span>
        
        <span class="c1"># Analyze network at each time point</span>
        <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">time_index</span><span class="p">:</span>
            <span class="c1"># Create a snapshot of the graph at the current time point</span>
            <span class="n">graph_t</span> <span class="o">=</span> <span class="n">get_graph_at_time</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span>
            
            <span class="c1"># Calculate accumulated pressure drops from source to all nodes</span>
            <span class="n">max_pressure_node</span><span class="p">,</span> <span class="n">max_pressure_value</span><span class="p">,</span> <span class="n">acc_pressures</span> <span class="o">=</span> <span class="n">calculate_accumulated_pressure_drop</span><span class="p">(</span>
                <span class="n">graph_t</span><span class="p">,</span> <span class="n">source_node</span>
            <span class="p">)</span>
            
            <span class="c1"># Calculate fluid density</span>
            <span class="k">if</span> <span class="nb">callable</span><span class="p">(</span><span class="n">config</span><span class="p">[</span><span class="s2">&quot;density_func&quot;</span><span class="p">]):</span>
                <span class="n">density</span> <span class="o">=</span> <span class="n">config</span><span class="p">[</span><span class="s2">&quot;density_func&quot;</span><span class="p">](</span><span class="n">t</span><span class="p">,</span> <span class="n">temp</span><span class="o">=</span><span class="n">graph_t</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">source_node</span><span class="p">][</span><span class="s2">&quot;temperature_supply&quot;</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">density</span> <span class="o">=</span> <span class="n">config</span><span class="p">[</span><span class="s2">&quot;density_func&quot;</span><span class="p">]</span>
                
            <span class="c1"># Calculate volume flow rate from mass flow [m/s]</span>
            <span class="n">source_edge</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">graph_t</span><span class="o">.</span><span class="n">edges</span><span class="p">(</span><span class="n">source_node</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">volume_flow</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">graph_t</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="n">source_edge</span><span class="p">][</span><span class="s2">&quot;m_flow&quot;</span><span class="p">])</span> <span class="o">/</span> <span class="n">density</span>
            
            <span class="c1"># Calculate total pressure drop [Pa]</span>
            <span class="n">dp_pump</span> <span class="o">=</span> <span class="n">config</span><span class="p">[</span><span class="s2">&quot;dp_pump&quot;</span><span class="p">]</span>  <span class="c1"># Internal pump pressure drop</span>
            <span class="c1"># Multiply by 2 to account for supply and return pipes</span>
            <span class="n">dp_tot</span> <span class="o">=</span> <span class="n">max_pressure_value</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">dp_pump</span>
            
            <span class="c1"># Calculate pump power using the formula: P = (dp_tot * V_dot) / (eta_pump * 1000) [kW]</span>
            <span class="n">eta_pump</span> <span class="o">=</span> <span class="n">config</span><span class="p">[</span><span class="s2">&quot;eta_pump&quot;</span><span class="p">]</span>
            <span class="n">pump_power</span> <span class="o">=</span> <span class="p">(</span><span class="n">dp_tot</span> <span class="o">*</span> <span class="n">volume_flow</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">eta_pump</span> <span class="o">*</span> <span class="mi">1000</span><span class="p">)</span>

            <span class="c1"># Create result entry with all calculated values</span>
            <span class="n">result_entry</span> <span class="o">=</span> <span class="p">{</span>
                <span class="s1">&#39;timestamp&#39;</span><span class="p">:</span> <span class="n">t</span><span class="p">,</span>
                <span class="s1">&#39;source_node&#39;</span><span class="p">:</span> <span class="n">source_node</span><span class="p">,</span>
                <span class="s1">&#39;max_pressure_node&#39;</span><span class="p">:</span> <span class="n">max_pressure_node</span><span class="p">,</span>
                <span class="s1">&#39;max_pressure_value&#39;</span><span class="p">:</span> <span class="n">max_pressure_value</span><span class="p">,</span>
                <span class="s1">&#39;dp_tot&#39;</span><span class="p">:</span> <span class="n">dp_tot</span><span class="p">,</span>
                <span class="s1">&#39;volume_flow&#39;</span><span class="p">:</span> <span class="n">volume_flow</span><span class="p">,</span>
                <span class="s1">&#39;pump_power&#39;</span><span class="p">:</span> <span class="n">pump_power</span><span class="p">,</span>
                <span class="s1">&#39;rho&#39;</span><span class="p">:</span> <span class="n">density</span><span class="p">,</span>
                <span class="s1">&#39;eta_pump&#39;</span><span class="p">:</span> <span class="n">eta_pump</span><span class="p">,</span>
                <span class="s1">&#39;dp_pump&#39;</span><span class="p">:</span> <span class="n">dp_pump</span><span class="p">,</span>
            <span class="p">}</span>
            
            <span class="c1"># Add pressure values for each node</span>
            <span class="k">for</span> <span class="n">node</span><span class="p">,</span> <span class="n">pressure</span> <span class="ow">in</span> <span class="n">acc_pressures</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">result_entry</span><span class="p">[</span><span class="sa">f</span><span class="s1">&#39;pressure_</span><span class="si">{</span><span class="n">node</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">pressure</span><span class="p">)</span>
                
            <span class="n">results</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">result_entry</span><span class="p">)</span>
            
    <span class="c1"># Create a DataFrame from the results</span>
    <span class="n">pump_power_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">results</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">graph</span><span class="p">,</span> <span class="n">pump_power_df</span></div>

<div class="viewcode-block" id="find_source_nodes"><a class="viewcode-back" href="../../code/uesgraphs.html#uesgraphs.analyze.find_source_nodes">[docs]</a><span class="k">def</span><span class="w"> </span><span class="nf">find_source_nodes</span><span class="p">(</span><span class="n">graph</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Identifies source nodes and their connected edges in a heating network graph.</span>
<span class="sd">    </span>
<span class="sd">    Source nodes are defined as nodes with the attribute &#39;is_supply_heating&#39; set to True.</span>
<span class="sd">    These typically represent heat generation facilities in district heating networks.</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    graph : networkx.Graph</span>
<span class="sd">        A graph representing a heating network with nodes potentially having</span>
<span class="sd">        the &#39;is_supply_heating&#39; attribute.</span>
<span class="sd">    </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    tuple</span>
<span class="sd">        A tuple containing two lists:</span>
<span class="sd">        - source_nodes: List of node identifiers that are marked as supply/source nodes</span>
<span class="sd">        - source_edges: List of edges (tuples) connecting source nodes to the network</span>
<span class="sd">    </span>
<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    ValueError</span>
<span class="sd">        If no source edges are found in the graph, making pump power calculation impossible.</span>
<span class="sd">    </span>
<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    - Multiple source nodes are allowed but will trigger a warning message</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">source_nodes</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">source_edges</span> <span class="o">=</span> <span class="p">[]</span>
    
    <span class="c1"># Identify all nodes marked as heat supply sources</span>
    <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">graph</span><span class="o">.</span><span class="n">nodes</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">graph</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">node</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;is_supply_heating&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">):</span>
            <span class="n">source_nodes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
            
            <span class="c1"># Get the edges connected to this source node</span>
            <span class="n">node_edges</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">graph</span><span class="o">.</span><span class="n">edges</span><span class="p">(</span><span class="n">node</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">node_edges</span><span class="p">:</span>  <span class="c1"># Check if the node has any connected edges</span>
                <span class="n">source_edges</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node_edges</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    
    <span class="c1"># Validation and warning messages</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">source_nodes</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;More than one source node found in graph </span><span class="si">{</span><span class="n">graph</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;name&#39;</span><span class="p">,</span><span class="w"> </span><span class="s1">&#39;unnamed&#39;</span><span class="p">)</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="ow">not</span> <span class="n">source_nodes</span><span class="p">:</span>
        <span class="n">error_msg</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;No source nodes found in graph </span><span class="si">{</span><span class="n">graph</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;name&#39;</span><span class="p">,</span><span class="w"> </span><span class="s1">&#39;unnamed&#39;</span><span class="p">)</span><span class="si">}</span><span class="s2">. Pump power calculation not possible.&quot;</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">error_msg</span><span class="p">)</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">error_msg</span><span class="p">)</span>
        
    <span class="k">return</span> <span class="n">source_nodes</span><span class="p">,</span> <span class="n">source_edges</span></div>

<div class="viewcode-block" id="get_graph_at_time"><a class="viewcode-back" href="../../code/uesgraphs.html#uesgraphs.analyze.get_graph_at_time">[docs]</a><span class="k">def</span><span class="w"> </span><span class="nf">get_graph_at_time</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">time_point</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Creates a snapshot of the graph at a specific time point.</span>
<span class="sd">    </span>
<span class="sd">    Extracts values from time series data (pandas Series) in both edge and node </span>
<span class="sd">    attributes at the specified time point to create a static graph representation.</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    graph : networkx.Graph or uesgraphs.UESGraph</span>
<span class="sd">        The input graph containing time series data as pandas Series in its </span>
<span class="sd">        node and edge attributes.</span>
<span class="sd">    time_point : datetime-like or hashable</span>
<span class="sd">        The time point at which to extract values from time series data.</span>
<span class="sd">        Must be a valid index for the pandas Series attributes.</span>
<span class="sd">    </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    uesgraph</span>
<span class="sd">        A new graph with the same structure as the input graph, but with </span>
<span class="sd">        time series attributes replaced by their values at the specified time point.</span>
<span class="sd">    </span>
<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    - Time series data should be stored as pandas Series with a time index</span>
<span class="sd">    - Non-time series attributes remain unchanged</span>
<span class="sd">    - Raises KeyError if time_point is not in the index of any time series</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">snapshot</span> <span class="o">=</span> <span class="n">graph</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    
    <span class="c1"># Process edge attributes</span>
    <span class="k">for</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">data</span> <span class="ow">in</span> <span class="n">snapshot</span><span class="o">.</span><span class="n">edges</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">data</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">key</span><span class="p">],</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">):</span>
                <span class="n">snapshot</span><span class="p">[</span><span class="n">u</span><span class="p">][</span><span class="n">v</span><span class="p">][</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">time_point</span><span class="p">]</span>
    
    <span class="c1"># Process node attributes</span>
    <span class="k">for</span> <span class="n">node</span><span class="p">,</span> <span class="n">data</span> <span class="ow">in</span> <span class="n">snapshot</span><span class="o">.</span><span class="n">nodes</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">data</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">key</span><span class="p">],</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">):</span>
                <span class="n">snapshot</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">node</span><span class="p">][</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">time_point</span><span class="p">]</span>
                
    <span class="k">return</span> <span class="n">snapshot</span></div>

<div class="viewcode-block" id="calculate_accumulated_pressure_drop"><a class="viewcode-back" href="../../code/uesgraphs.html#uesgraphs.analyze.calculate_accumulated_pressure_drop">[docs]</a><span class="k">def</span><span class="w"> </span><span class="nf">calculate_accumulated_pressure_drop</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">source_node</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="s2">&quot;press_drop&quot;</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculate the accumulated pressure drop from a source node to all other nodes in the network.</span>
<span class="sd">    </span>
<span class="sd">    This function uses Dijkstra&#39;s algorithm to determine the shortest path from the source node</span>
<span class="sd">    to all other nodes in the graph, where the path length is weighted by the pressure drop. </span>
<span class="sd">    It returns the node with the maximum accumulated pressure drop, its value, and a dictionary </span>
<span class="sd">    containing the accumulated pressure drop for all nodes.</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    graph : networkx.Graph or uesgraphs.UESGraph</span>
<span class="sd">        A graph representing a heating network with &#39;press_drop&#39; attributes on edges.</span>
<span class="sd">    source_node : node</span>
<span class="sd">        The starting node (typically a heat source or plant) from which to calculate </span>
<span class="sd">        accumulated pressure drops.</span>
<span class="sd">    key : str, optional</span>
<span class="sd">        The edge attribute name used to calculate the pressure drop. Default is &#39;press_drop&#39;.</span>
<span class="sd">    </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    tuple</span>
<span class="sd">        A tuple containing three elements:</span>
<span class="sd">        - max_pressure_node : The node with the maximum accumulated pressure drop</span>
<span class="sd">        - max_pressure_value : float, the maximum accumulated pressure drop value</span>
<span class="sd">        - acc_pressures : dict, mapping each node to its accumulated pressure drop from source</span>
<span class="sd">    </span>
<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    - The edge attribute key (default: &quot;press_drop&quot;) must exist for all edges in the network</span>
<span class="sd">    - This function is essential for identifying critical paths in the network</span>
<span class="sd">    - The maximum pressure drop node often represents the hydraulic critical consumer</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Calculate accumulated pressure drops to all nodes using Dijkstra&#39;s algorithm</span>
    <span class="n">acc_pressures</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">single_source_dijkstra_path_length</span><span class="p">(</span>
        <span class="n">graph</span><span class="p">,</span> <span class="n">source_node</span><span class="p">,</span> <span class="n">weight</span><span class="o">=</span><span class="n">key</span>
    <span class="p">)</span>
    
    <span class="c1"># Find the node with the maximum accumulated pressure drop</span>
    <span class="n">max_pressure_node</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">acc_pressures</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">acc_pressures</span><span class="o">.</span><span class="n">get</span><span class="p">)</span>
    
    <span class="c1"># Get the maximum pressure drop value</span>
    <span class="n">max_pressure_value</span> <span class="o">=</span> <span class="n">acc_pressures</span><span class="p">[</span><span class="n">max_pressure_node</span><span class="p">]</span>
    
    <span class="k">return</span> <span class="n">max_pressure_node</span><span class="p">,</span> <span class="n">max_pressure_value</span><span class="p">,</span> <span class="n">acc_pressures</span></div>

<div class="viewcode-block" id="calculate_pump_energy"><a class="viewcode-back" href="../../code/uesgraphs.html#uesgraphs.analyze.calculate_pump_energy">[docs]</a><span class="k">def</span><span class="w"> </span><span class="nf">calculate_pump_energy</span><span class="p">(</span><span class="n">pump_power_df</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculate energy consumption from pump power time series data.</span>
<span class="sd">    </span>
<span class="sd">    This function calculates the energy consumption of pumps by integrating</span>
<span class="sd">    power values over time. It computes the time differences between consecutive </span>
<span class="sd">    measurements, calculates energy consumption for each interval, and provides </span>
<span class="sd">    cumulative energy values.</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    pump_power_df : pandas.DataFrame</span>
<span class="sd">        DataFrame containing pump power data with a &#39;timestamp&#39; column in</span>
<span class="sd">        datetime format and a &#39;pump_power&#39; column containing power values in kW.</span>
<span class="sd">    </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    pandas.DataFrame</span>
<span class="sd">        The input DataFrame with additional columns:</span>
<span class="sd">        - time_diff: timedelta between consecutive timestamps</span>
<span class="sd">        - time_diff_hours: time difference in hours</span>
<span class="sd">        - energy: energy consumed in each interval in kWh</span>
<span class="sd">        - cumulative_energy: running sum of energy consumption in kWh</span>
<span class="sd">    </span>
<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    - This function assumes that the power remains constant between timestamps</span>
<span class="sd">    - Timestamps must be sortable datetime objects</span>
<span class="sd">    - The first interval uses a time difference of 0, resulting in 0 energy</span>
<span class="sd">    - Energy calculation is based on the formula: Energy (kWh) = Power (kW)  Time (h)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Sort by timestamp to ensure chronological order for accurate time differencing</span>
    <span class="n">sorted_df</span> <span class="o">=</span> <span class="n">pump_power_df</span><span class="o">.</span><span class="n">sort_values</span><span class="p">(</span><span class="s1">&#39;timestamp&#39;</span><span class="p">)</span>
    
    <span class="c1"># Calculate time differences between consecutive measurements</span>
    <span class="n">sorted_df</span><span class="p">[</span><span class="s1">&#39;time_diff&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">sorted_df</span><span class="p">[</span><span class="s1">&#39;timestamp&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">diff</span><span class="p">()</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="n">pd</span><span class="o">.</span><span class="n">Timedelta</span><span class="p">(</span><span class="n">hours</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span>
    
    <span class="c1"># Convert time differences to hours for energy calculation (kW  h = kWh)</span>
    <span class="n">sorted_df</span><span class="p">[</span><span class="s1">&#39;time_diff_hours&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">sorted_df</span><span class="p">[</span><span class="s1">&#39;time_diff&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">dt</span><span class="o">.</span><span class="n">total_seconds</span><span class="p">()</span> <span class="o">/</span> <span class="mi">3600</span>
    
    <span class="c1"># Calculate energy consumption for each time interval (kWh)</span>
    <span class="n">sorted_df</span><span class="p">[</span><span class="s1">&#39;energy&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">sorted_df</span><span class="p">[</span><span class="s1">&#39;pump_power&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="n">sorted_df</span><span class="p">[</span><span class="s1">&#39;time_diff_hours&#39;</span><span class="p">]</span>
    
    <span class="c1"># Calculate running total of energy consumption</span>
    <span class="n">sorted_df</span><span class="p">[</span><span class="s1">&#39;cumulative_energy&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">sorted_df</span><span class="p">[</span><span class="s1">&#39;energy&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">cumsum</span><span class="p">()</span>
    
    <span class="k">return</span> <span class="n">sorted_df</span></div>

<div class="viewcode-block" id="plot_pump_energy"><a class="viewcode-back" href="../../code/uesgraphs.html#uesgraphs.analyze.plot_pump_energy">[docs]</a><span class="k">def</span><span class="w"> </span><span class="nf">plot_pump_energy</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">output_dir</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generate a visualization of cumulative pump energy consumption over time.</span>
<span class="sd">    </span>
<span class="sd">    Creates a time series plot of the cumulative energy consumption from the pump</span>
<span class="sd">    power analysis results, with adaptive time axis formatting based on the data range.</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    df : pandas.DataFrame</span>
<span class="sd">        DataFrame containing pump energy data with at minimum the following columns:</span>
<span class="sd">        - timestamp: datetime or convertible to datetime</span>
<span class="sd">        - cumulative_energy: float, the cumulative energy consumption in kWh</span>
<span class="sd">    output_dir : str or Path, optional</span>
<span class="sd">        Directory where the plot should be saved. If None, the plot is not saved.</span>
<span class="sd">    label : str, default=&quot;&quot;</span>
<span class="sd">        Label for the data series in the plot legend.</span>
<span class="sd">    </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    None</span>
<span class="sd">        The function displays the plot and optionally saves it to disk.</span>
<span class="sd">    </span>
<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    - The function automatically formats the time axis based on the data time range</span>
<span class="sd">    - The plot is saved as &#39;energy_consumption_plot.png&#39; if output_dir is provided</span>
<span class="sd">    - The figure is displayed using plt.show() which may block execution in non-interactive environments</span>
<span class="sd">    &quot;&quot;&quot;</span>

    
    <span class="c1"># Convert timestamp to datetime if it&#39;s not already</span>
    <span class="n">df</span><span class="p">[</span><span class="s1">&#39;timestamp&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">to_datetime</span><span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="s1">&#39;timestamp&#39;</span><span class="p">])</span>
    
    <span class="c1"># Create figure with appropriate size for time series visualization</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">12</span><span class="p">,</span> <span class="mi">6</span><span class="p">))</span>
    
    <span class="c1"># Plot the cumulative energy consumption</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="s1">&#39;timestamp&#39;</span><span class="p">],</span> <span class="n">df</span><span class="p">[</span><span class="s1">&#39;cumulative_energy&#39;</span><span class="p">],</span> <span class="n">label</span><span class="o">=</span><span class="n">label</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
    
    <span class="c1"># Determine appropriate date formatting based on the data time range</span>
    <span class="n">time_range</span> <span class="o">=</span> <span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="s1">&#39;timestamp&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">-</span> <span class="n">df</span><span class="p">[</span><span class="s1">&#39;timestamp&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">min</span><span class="p">())</span><span class="o">.</span><span class="n">total_seconds</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">time_range</span> <span class="o">&gt;</span> <span class="mi">86400</span> <span class="o">*</span> <span class="mi">30</span><span class="p">:</span>  <span class="c1"># More than 30 days</span>
        <span class="n">date_format</span> <span class="o">=</span> <span class="s1">&#39;%Y-%m-</span><span class="si">%d</span><span class="s1">&#39;</span>
        <span class="n">locator</span> <span class="o">=</span> <span class="n">mdates</span><span class="o">.</span><span class="n">WeekdayLocator</span><span class="p">(</span><span class="n">interval</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>  <span class="c1"># Weekly ticks</span>
    <span class="k">elif</span> <span class="n">time_range</span> <span class="o">&gt;</span> <span class="mi">86400</span> <span class="o">*</span> <span class="mi">7</span><span class="p">:</span>  <span class="c1"># More than a week</span>
        <span class="n">date_format</span> <span class="o">=</span> <span class="s1">&#39;%Y-%m-</span><span class="si">%d</span><span class="s1">&#39;</span>
        <span class="n">locator</span> <span class="o">=</span> <span class="n">mdates</span><span class="o">.</span><span class="n">DayLocator</span><span class="p">(</span><span class="n">interval</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>  <span class="c1"># Every other day</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">date_format</span> <span class="o">=</span> <span class="s1">&#39;%m-</span><span class="si">%d</span><span class="s1"> %H:%M&#39;</span>
        <span class="n">locator</span> <span class="o">=</span> <span class="n">mdates</span><span class="o">.</span><span class="n">DayLocator</span><span class="p">(</span><span class="n">interval</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>  <span class="c1"># Daily ticks</span>
    
    <span class="c1"># Apply date formatting to the x-axis</span>
    <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">gca</span><span class="p">()</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">xaxis</span><span class="o">.</span><span class="n">set_major_locator</span><span class="p">(</span><span class="n">locator</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">xaxis</span><span class="o">.</span><span class="n">set_major_formatter</span><span class="p">(</span><span class="n">mdates</span><span class="o">.</span><span class="n">DateFormatter</span><span class="p">(</span><span class="n">date_format</span><span class="p">))</span>
    
    <span class="c1"># Rotate date labels for better readability</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">xticks</span><span class="p">(</span><span class="n">rotation</span><span class="o">=</span><span class="mi">45</span><span class="p">,</span> <span class="n">ha</span><span class="o">=</span><span class="s1">&#39;right&#39;</span><span class="p">)</span>
    
    <span class="c1"># Add grid for better data interpretation</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="kc">True</span><span class="p">,</span> <span class="n">linestyle</span><span class="o">=</span><span class="s1">&#39;--&#39;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.7</span><span class="p">)</span>
    
    <span class="c1"># Ensure sufficient space for labels and other elements</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>
    
    <span class="c1"># Configure y-axis formatter for consistent energy value representation</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">matplotlib.ticker</span><span class="w"> </span><span class="kn">import</span> <span class="n">FuncFormatter</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">kwh_formatter</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">pos</span><span class="p">):</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">x</span><span class="si">:</span><span class="s1">.1f</span><span class="si">}</span><span class="s1">&#39;</span>
    
    <span class="n">ax</span><span class="o">.</span><span class="n">yaxis</span><span class="o">.</span><span class="n">set_major_formatter</span><span class="p">(</span><span class="n">FuncFormatter</span><span class="p">(</span><span class="n">kwh_formatter</span><span class="p">))</span>
    
    <span class="c1"># Add titles and axis labels</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;Cumulative Energy Consumption Over Time&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">14</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;Timestamp&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">12</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;Cumulative Energy (kWh)&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">12</span><span class="p">)</span>
    
    <span class="c1"># Show legend only if label is provided</span>
    <span class="k">if</span> <span class="n">label</span><span class="p">:</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
    
    <span class="c1"># Save the plot if output directory is specified</span>
    <span class="k">if</span> <span class="n">output_dir</span><span class="p">:</span>
        <span class="n">output_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">output_dir</span><span class="p">,</span> <span class="s1">&#39;energy_consumption_plot.png&#39;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="n">output_path</span><span class="p">,</span> <span class="n">dpi</span><span class="o">=</span><span class="mi">300</span><span class="p">,</span> <span class="n">bbox_inches</span><span class="o">=</span><span class="s1">&#39;tight&#39;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Plot saved to </span><span class="si">{</span><span class="n">output_path</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    
    <span class="c1"># Display the plot</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span></div>

<div class="viewcode-block" id="plot_network"><a class="viewcode-back" href="../../code/uesgraphs.html#uesgraphs.analyze.plot_network">[docs]</a><span class="k">def</span><span class="w"> </span><span class="nf">plot_network</span><span class="p">(</span><span class="n">graph</span><span class="p">):</span>
    <span class="n">vis</span> <span class="o">=</span> <span class="n">ug</span><span class="o">.</span><span class="n">Visuals</span><span class="p">(</span><span class="n">graph</span><span class="p">)</span>
    <span class="n">fig</span> <span class="o">=</span> <span class="n">vis</span><span class="o">.</span><span class="n">show_network</span><span class="p">(</span><span class="n">show_plot</span><span class="o">=</span><span class="n">show_plot</span><span class="p">)</span></div>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2025, Rahul Karuvingal.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>